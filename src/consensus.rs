use std::fmt;
use bio::alignment::{pairwise::Scoring, poa::Aligner};
use log::debug;
use rand::seq::IteratorRandom;

#[derive(Clone)]
pub struct Consensus {
    pub seq: Option<String>,
    pub support: usize,
    pub std_dev: usize,
    pub score: i32,
}

impl Default for Consensus {
    fn default() -> Consensus {
        Consensus {
            seq: None,
            support: 0,
            std_dev: 0,
            score: -1,
        }
    }
}

impl fmt::Display for Consensus {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match &self.seq {
            Some(seq) => write!(
                f,
                "seq: {}, support: {}, std_dev: {}, score: {}",
                seq, self.support, self.std_dev, self.score
            ),
            None => write!(f, "seq: None, support: 0, std_dev: 0, score: -1"),
        }
    }
}

pub fn consensus(
    seqs: &[String],
    support: usize,
    consensus_reads: usize,
    repeat: &crate::repeats::RepeatInterval,
) -> Consensus {
    if seqs.is_empty() {
        return Consensus {
            seq: None,
            support: 0,
            std_dev: 0,
            score: -1,
        };
    }
    let num_reads_ = seqs.len();
    let (seqs, std_dev) = remove_outliers(seqs, repeat);
    let num_reads = seqs.len();
    debug!(
        "{repeat}: Kept {}/{} reads after dropping outliers",
        num_reads, num_reads_
    );
    if num_reads < support {
        Consensus {
            seq: None,
            support: num_reads,
            std_dev,
            score: -1,
        }
    } else if consensus_reads == 1 {
            // if only on read should be used to generate the consensus, the consensus is a randomly selected read
            let seq = seqs.into_iter().choose(&mut rand::rng()).unwrap();
            Consensus {
                seq: Some(seq.to_string()),
                support: num_reads,
                std_dev,
                score: 0,
            }
    } else {
        // if there are more than <consensus_reads> reads, downsample before taking the consensus
        // for performance and memory reasons
        let seqs_bytes = if num_reads > consensus_reads {
            debug!("{repeat}: Too many reads, downsampling to {consensus_reads}");
            seqs.into_iter().choose_multiple(&mut rand::rng(), consensus_reads)
            .into_iter().cloned()
            .map(|seq| seq.bytes().collect::<Vec<u8>>())
            .collect::<Vec<Vec<u8>>>()
        } else {
            seqs.iter().map(|seq| seq.bytes().collect::<Vec<u8>>()).collect::<Vec<Vec<u8>>>()
        };
        // I empirically determined the following parameters to be suitable,
        // but further testing on other repeats would be good
        // mainly have to make sure the consensus does not get longer than the individual insertions
        log::info!("Creating consensus for {repeat}");
        let scoring = Scoring::new(-12, -6, |a: u8, b: u8| if a == b { 3 } else { -4 });
        let mut aligner = Aligner::new(scoring, &seqs_bytes[0]);
        for seq in seqs_bytes.iter().skip(1) {
            aligner.global(seq).add_to_graph();
        }
        debug!("Added all sequences to graph");

        let consensus = aligner.consensus();
        debug!("Created consensus");
        let score = aligner.global(&consensus).alignment().score;
        debug!("Calculated score");
        Consensus {
            seq: Some(std::str::from_utf8(&consensus).unwrap().to_string()),
            support: num_reads,
            std_dev,
            score,
        }
    }
}

fn remove_outliers<'a>(
    seqs: &'a [String],
    repeat: &crate::repeats::RepeatInterval,
) -> (Vec<&'a String>, usize) {
    // remove sequences that are shorter or longer than two standard deviations from the mean
    // except if the stdev is small
    let lengths = seqs.iter().map(|x| x.len()).collect::<Vec<usize>>();
    debug!("{repeat}: lengths: {:?}", lengths);

    let mean = lengths.iter().sum::<usize>() / lengths.len();
    let variance = lengths
        .iter()
        .map(|x| (*x as isize - mean as isize).pow(2) as usize)
        .sum::<usize>()
        / lengths.len();
    // note that the casting to usize will floor the std_dev to the integer below, rather than properly rounding it to the nearest integer
    // so this keeps the std_dev smaller than it really is, but not by a lot
    // the places where this matter are probably negligible
    let std_dev = (variance as f64).sqrt() as usize;
    debug!("mean: {}, std_dev: {}", mean, std_dev);
    if std_dev < 5 {
        debug!("std_dev < 5, not removing any outliers");
        (seqs.iter().collect::<Vec<&String>>(), std_dev)
    } else {
        // avoid underflowing usize
        let min_val = mean.saturating_sub(2 * std_dev);
        let max_val = mean + 2 * std_dev;
        debug!("Removing outliers outside of [{},{}]", min_val, max_val);
        let filtered_seqs = seqs
            .iter()
            .zip(lengths.iter())
            .filter(|(_, &len)| len > min_val && len < max_val)
            .map(|(seq, _)| seq)
            .collect::<Vec<&String>>();
        (filtered_seqs, std_dev)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use bio::alignment::pairwise::Scoring;
    #[test]
    fn test_consensus() {
        // I created this test because these sequences segfaulted on bianca
        let seqs = vec![
            "CAGACAGGCAGGCAGGCAGGCAGGCAGGCAGGCAGACAGGCAGCCAGGCAGGCAGGCAGG".to_string(),
            "CAGGCAGGCAGGCAGGCAGGCAGGCAGGCAGACAGGCAGCCAGGCAGGCAGGCAGG".to_string(),
            "AGACAGACAGGCAGGCAGGCAGGCAGGCAGGCAGGCAGACAGGCAGCCAGGCAGGCAGGCAGGC".to_string(),
            "GGCAGGCAGGCAGGCAGGCAGGCAGACAGGCAGCCAGGCAGGCAGGCAGGCAGACAGAAG".to_string(),
            "CAGGCAGGCAGGCAGGCAGGCAGGCAGGCAGACAGGCAGCCAGGCAGGCAGGCAGG".to_string(),
            "CAGGCAGGCAGGCAGGCAGGCAGGCAGGCAGACAGGCAGCCAGGCAGGCAGGCAGG".to_string(),
            "CAGACAGGCAGGCAGGCAGGCAGGCAGGCAGGCAGACAGGCAGCCAGGCAGGCAGGCAGG".to_string(),
            "CAGGCAGGCAGGCAGGCAGGCAGGCAGGCAGACAGGCAGCCAGGCAGGCAGGCAGG".to_string(),
            "AGACAGACAGGCAGGCAGGCAGGCAGGCAGGCAGGCAGACAGGCAGCCAGGCAGGCAGGCAGGC".to_string(),
            "CAGGCAGGCAGGCAGGCAGGCAGGCAGGCAGACAGGCAGCCAGGCAGGCAGGCAGG".to_string(),
            "CAGGCAGGCAGGCAGGCAGGCAGGCAGGCAGACAGGCAGCCAGGCAGGCAGGCAGG".to_string(),
            "CAGGCAGGCAGGCAGGCAGGCAGGCAGGCAGACAGGCAGCCAGGCAGGCAGGCAGG".to_string(),
            "CAGGCAGGCAGGCAGGCAGGCAGGCAGGCAGACAGGCAGCCAGGCAGGCAGGCAGG".to_string(),
            "CAGGCAGGCAGGCAGGCAGGCAGGCAGGCAGACAGGCAGCCAGGCAGGCAGGCAGG".to_string(),
            "CAGACAGGCAGGCAGGCAGGCAGGCAGGCAGACAGGCAGCCAGGCAGGCAGGCAGG".to_string(),
            "ACAGACAGGCAGGCAGGCAGGCAGGCAGGCAGACAGGCAGCCAGGCAGGCAGGCAGACAGAA".to_string(),
            "CAGGCAGGCAGGCAGGCAGGCAGGCAGGCAGACAGGCAGCCAGGCAGGCAGGCAGG".to_string(),
            "CAGGCAGGCAGGCAGGCAGGCAGGCAGGCAGACAGGCAGCCAGGCAGGCAGGCAGG".to_string(),
            "CAGGCAGGCAGGCAGGCAGGCAGGCAGGCAGACAGGCAGCCAGGCAGGCAGGCAGG".to_string(),
            "CAGGCAGGCAGGCAGGCAGGCAGGCAGGCAGACAGGCAGCCAGGCAGGCAGGCAGG".to_string(),
        ];
        let cons = consensus(
            &seqs,
            10,
            20,   
            &crate::repeats::RepeatInterval {
                chrom: "chr1".to_string(),
                start: 1,
                end: 100,
                created: None
            },
        );
        println!("Consensus: {}", cons.seq.unwrap());
        println!("Num reads: {}", cons.support);
        println!("Std dev: {}", cons.std_dev);
        println!("Consensus score: {}", cons.score);
    }

    #[test]
    fn test_consensus_2() {
        let seqs = vec![        
            "GGGGGGAGGAGGGGGGAGGAGGGGGGAGGAGGACAGGCAAGGAGGCCTCGAAGAGGGAAGACCAGAGAAGGAGGGGAAGGGGAGAGCGGAGGGAAAGAGGTGGGATAAGGAAGAGAAGGAGGAGGAAGGGGAAGAGGGAGG".to_string(),
            "GGGGGGAGGAGGGGGGAGGAGGGGGGAGGAGGACAGGCAAGGAGGCCTCGAAGAGGGAAGACCAGAGAAGGAGGGGAAGGGGAGAGCGGAGGGAAAGAGGTGGGATAAGGAAGAGAAGGAGGAGGAAGGGGAAGAGGGAGG".to_string(),
            "AGGAGGAGGGAGGCGGGGGGAGGAGGGGGGAGGAGGGGGGAGGAAGGACAGGCAAGGAGGCCTCGAAGAGGGAAGACCAGAGAAGGAGGGGAAGGGGAGAGCGAGAAGAAGGTGGGATGAGGAAGGAAAGGAGC".to_string(),
            "GGGGGAGGAGGGGGGAGGAGGGGGGAGGAGGACAGGCAGTGGTGGCTCCGAAGAGGGAAGACCAGAGAAGGAGGGGAAGGGGAGAGCGGAGGGAAAGAGGTGGGATAAGGAAGAGAAGGAGGAGGAAGGGGAAGAGGGAGG".to_string(),
            "GGGGGGAGGAGGGGGGAGGAGGGGGGAGGAGGGACAGGGCAAGGAGGCCTCGAAGAGGGAAGACCAGAGAAGGAGGGGAAGGGGAGAGCGAGGGAGAGAAGGATGAGGGAGTAGGGAAGGAAAGGAGGAGGAAGGGGAAGAGGGAGG".to_string(),
            "GGGGGGAGGAGGGGGGAGGAGGGGGAGGAGGACAGGCAAGGAGGCCTCGAAGAGGGAAGACCAGAGAAGGAGGGGAAGGGGAGAGCGGAGGGAAAGAGGTGGGATAAGGAAGAGAAGGAGGAGGAAGGGAAGAGGGAGG".to_string(),
            "GGGGGGAGGAGGGGGAGGAGGGGAGGAGGACAGGCAAGGAGGCCTCGAAGAGGGAAGACCAGAGAAGGAGGGGAAGGGGAGAGCGGAGGGAAAGAGGTGGGATAAGGAAGAGAAGGAGGAGGAAGGGGAAGAGGGAGG".to_string(),
            "GGGGGGAGGAGGGGGGAGGAGGGGGGAGGAGGACAGGCAAGGAGGCCTCGAAGAGGGAAGACCAGAGAAGGAGGGGAAGGGGAGAGCGGAGGGAAAGAGGTGGGATAAGGAAGAGAAGGAGGAGGAAGGGGAAGAGGGAGG".to_string(),
            "GGGGGGAGGAGGGGGAGGAGGGGGGAGGAGGACAGGCAAGGAGGCCTGGGAGAGAGGGAAGACCAGAGAAGGAGGGGAAGGGGAGAGCGAGGAAAGAGGTGGGATAAGGAAGAAGGAGGAGGAAGGGGAAGAGGGAGG".to_string(),
            "GGGGGGAGGAGGGGGGAGGAGGGGGAGGAGGACAGGCAAGGAGGCCTCGAAGAGGGAAGACCAGAGAAGGAGGGGAAGGGGAGAGCGGAGGGAAAGAGGTGGGATAAGGAAGAGAAGGAGGAGGAAGGGGAAGAGGGAGG".to_string(),
            "GGGGGGAGGAGGGGGGAGGAGGGGGAGGAGGACAGGCAAGGAGGCCTCGAAGAGGGAAGACCAGAGAAGGAGGGGAAAGGGGAGAGCGGAGGGAAGAGGTGGGATAAGGAAGAGAAGGAGGAGGAAGGGGAAGAGGGAGG".to_string(),
            "GGGGGGAGGAGGGGGAGGAGGGGGGAGGAGGACAGGCAAGGAGGCCTCGAAGAGGGAAGACCAGAGAAGGAGGGGAAGGGGAGAGCGGAGGGAAAGAGGTGGGATAAGGAAGAGAAGGAGGAGGAAGGGGAAGAGGGAGG".to_string(),
            "GGGGGGAGGAGGGGGAGGAGGGGAGGAGGACAGGCAAGGAGGCCTCGAAGAGGGAAGACCAGAGAAGGAGGGGAAGGGGAGAGCGGAGGGAAAGAGGTGGGATAAGAAGAGAAGGAGGAGGAAGGGGAAGAGGGAGG".to_string(),
            "GGGGGGAGGAGGGGGGAGGAGGGGGGAGGAGGACAGGCAAGGAGGCCTCGAAGAGGGAAGACCAGAGAAGGAGGGGAAGGGGAGAGCGGAGGGAAAGAGGTGGGATAAGGAAGAGAAGGAGGAGGAAGGGGAAGAGGGAGG".to_string(),
            "GGGGGAGGAGGGGGGAGGAGGGGGGAGGAGGACAGGCAAGGAGGCCTCGAAGAGGGAAGACCAGAGAAGGAGGGGAAGGGGAGAGCGGAGGGAAAGAGGTGGGATAAGGAAGAGAAGGAGGAGGAAGGGGAAGAGGGAGG".to_string(),
            "GGGGGGAGGAGGGGGAGGAGGGGGAGGAGGACAGGGAAGGAGGCCTCGAAGAGGGAAGACCAGAGAAGGAGGGGGAAGGGAGAGCGGAGGGGAAAAGAGGTGGGATAAGGAAGAGAAGGAGGAGGAAGGGGAAGAGGGAGG".to_string(),
        ];
        let mut seqs_bytes = vec![];
        for seq in seqs.iter() {
            seqs_bytes.push(seq.to_string().bytes().collect::<Vec<u8>>());
        }

        // I empirically determined the following parameters to be suitable,
        // but further testing on other repeats would be good
        // mainly have to make sure the consensus does not get longer than the individual insertions
        let scoring = Scoring::new(-12, -6, |a: u8, b: u8| if a == b { 3 } else { -4 });
        let mut aligner = Aligner::new(scoring, &seqs_bytes[0]);
        for seq in seqs_bytes.iter().skip(1) {
            aligner.global(seq).add_to_graph();
        }

        let consensus = aligner.consensus();
        let score = aligner.global(&consensus).alignment().score;


        println!("Consensus: {}", std::str::from_utf8(&consensus).unwrap());
        println!("Consensus score: {}", score);

    }

    #[test]
    fn test_consensus_3() {
        let seqs = vec![
            "TCTTTCTTTCTTTCTTTCCTTTCCTTTCCTTTCCTTTCCTTCCTTTCCTTCCTTCCTTCCTTCCTTCCTTCCTCCCTCACTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCCCTCTCCCTCTCCCTCTCCCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCCCTCCCTCTCCCTCTCTCTCTCTCTCTCCCTCTCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCTCTCCTCTCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCTCTCCTCTCCTCTCTCTCCTCTCCTCTCCTCTCCCTCTCCCTCTCCTCTCCCTCTCCCTCTCCTGCTCCCTCTCCTCTCCCTCTCCCTCCTCCTCCCTCTCCTCTCCCTCCCTCCTTTCTCCCTCTCTCCCTCTCCCTCTCCCTCTCCCCTCTCCTCTCCTCTCCCTCTCCCTCTCCCCTCTCCCTCTCCCTCCTCCCTCTCCTCTCCCTCTCCCTCTCCTCCTCCCTCTCCCTCTCCCTCTCTCCCTCTCCCTCTCCCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCCTCTCCCTCTCCCCTCTCCTCTCCTCTCCCCCTCTCCTCTCCTCTCCCTCTCCCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTTTCTTTCTTT".to_string(),
            "TTCTTTCCTTCCTTTCCTTTCTTTCCTTTCCTTCCTTCCTTTCCTTCCTTCCTTCCTTCCTTCCTTCCTCCCTCCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCCCTCTCCCTCTCCCTCTCCCTCCCTCTCCCTCTCTCCCTCTCCCTCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCTCTCTCTCTCTCTCTCTCTCCCTCTCCCTCCCTCTCTCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCTCTCTCTCTCTCTCCCTCCTCTCCCTCTCCCTCTCCCTCTCTCCCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCCCTCTCCCTCTCCCTCCCTCTCCCTCCCTCTCCCTCTCCCTCTCCCTCTCTCCCTCTCCCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCCCTCCCTCCCTCCCTCTCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCTCCCTCCTCCCTCTCTCTCTCTCCCTCTCCCTCCCTCTCCCTCTCCCTCTCCCTCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTTTCTTTCTTTCTTTCTTCCC".to_string(),
            "CTTTTCTTTCCTTTCCTTTCCTTTCCTTTCCTTTCCTTCCTTTCCTTCCTTCCTTCCTTCCTTCCTTCCCTCCCTCCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCCTTTCTCCTCTCCCTCCCTCCCTCTCCCTCTCCCCCCTCCCTCTCCCTCCCTCTCCCTCTCTCCCTCTCTCTCCCTCCTCCTCTCCTCCCTCCCTCCTCTCCTCTCCCTCCTCCTCTCCTCTCCTCTCTCCTCCTCTCCCTCTCCTCTCCTCCCTCCTCTCCTCCTCCCTCTCCTCTCCTCCTCTCCTCTCCTCTCCTCTCCTCCTCTCCTCTCTCCCTCCTCTCCTCCCTCCTCCCTCCCTCCTCCTCTTCCCTCCTCTCCTCCTCCTCCTCCTCTCCTCTCCTCCTCCTCCCTCCCTCCTCTTCCTCTCTCCCTCTCCTTCTCCCTCTCTCTCCCTCCCTCCTCTCCTCCTCTCCCTCTCCTCCTCTCCCTCTCCTCTCCTCCTCCTCTCCTCTCCTCTCCTCTCCTCTCCTCTCCCTCTCCCTCTCCCTCTCCCTCCCTCCCTCTCCCTCTCCCTCTCTCTCCCTCCCTCTCCCTCCCTCTCCTCTCTCTCTCTCTCTTCTTTTTCTTTCTTTCCTCG".to_string(),
            "TCTTTCTTTCTTTCTTTTCCTTTCCTTTCCTTTCCTTTCCTTTCCTTCCTTTCCTTCCTTCCTTCCTTCCTTCCTTCCTCCCTCCCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCCCTCTCCCTCTCCCTCTCCCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCCCTCTCCCTCTCCCTCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCTCTCCCTCTCCCTCTCTCCCTCTCCCTCTCCCTCTCCCTCTCTCTCTCCCTCTCCCTCTCCCTCTCCCTCTCTCTCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCTCTCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCTCTCTCCCTCCCTCCCTCTCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCTCCCTCCCTCTCTCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTTTCTTTCTTT".to_string(),
            "TCTTTCTTTCCTTTCCTTTCCTTTCTTTCTCCTTCCTTCCTTCCTTCCTTCCTTCCTTCCTTCCTCCCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCCCTCTCCCTCTCCCTCTCCCTCCCTCTCCCTCCCTCTCCCTCTCCCTCTCCCTCTCTCCCTCTCCCTCTCCCTCTCCCTCCTCTCCCTCTCCTCTCCCTCTCTCTCTCCCTCTCCCTCTCCCTCCCTTCCTCCCTCTCCTCCTCCCTCTCTCTCCTCTCCCTCTCTCTCTCTCCCTCTCCCTCTCCCTCTCTCTCTCTCCCCTCTCCCTCTCCCTCCTCCCTCTCCCTCTCCTTCTCTCTCCCTCTCCTCTCCCTCTCCCTCTCCCCTCCCTCTCCCTCTCCCTCTCCCTTCTCCCTCCTCTTCTCCTCTCCTCTCCTCTCCTCTCCCTCCTCCTCTCCTCCTCTCCTCTCCCTCTCCTCTCCCTCTCCCTCTCCTCTCCCCTCTCCTCTCCCTCTCCCTCTCCCTCTCCTCTCCCTCTCCCTCTCCTCTCCCTCTCCTCTCCTCTCCCTCTCCCTCTCCCTCCTCCCTCTCCCTCTCCTCCCTCTCCCTCCTCCCTCTCCCTCTCCTCCTCCCTCCCTCCCTCCCTCTCCCCTCTCCCTCTCCCTCCCTCCCTCTCCTCTCCCTCTCCTCTCCTCTCCTCCTCCCTCTCCCTCCCTCCCTCTCTCCCTCTCTCTCTCTCTCTCTCTCTTTCTTTCTTTCTTTTTC".to_string(),
            "TCTTTCTTTCTTTCTTTCCTTTCCTTTCCTTTCTTTCCTTTCCTTCCTTTCCTTCCTTCCTTCCTTCCTTCCTTCCTCCCTCCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCCCTCTCCCTCTCCCTCTCCCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCCCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCTCTCCCTCTCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCCTCTCCTCTCCCTCTCCCTCTCCCTCTCCTCTCCCCTCTCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCTCTCCTCTCCTCTCCTCTCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTTTCTTTCTTT".to_string(),
            "TCTTTCTTTCTTTCTTTCCTTTCCTTTCCTTTCCTTTCCTTTCCTTCCTTTTCCTTCCTTCCTTCCTTCCTTCCTTCCTCCCTCCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCCCTCTCCCTCTCCTCTCCCTCCCTCTCCCTCTCCCTCTCCCTCCTCCCTCTCCCTCTCCCTCTCCCTCTCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCCCTCTCCCTCTCCCTCTCCCTCTCCTCTCTCTCCCTCTCCCTCTCCCTCTTTCCCTCTCCCTCTCCCTCTCCCCTCTCCCTCTCCCTCTCCCTCCCTCTCCCTCCCTCTCCCTCTCCCTCCTCTCTCTCCCTCTCCCTCCTCCCTCTCCTCCTCCTCTCCCTTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTTCTCCCTCTCCCTCCTCTCCCTCTCCCTCTCTCTCCCTCTCCTCTCCCTCCCTCCCTTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCTCTCCCTCCCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCTCTCCTCTCCCTCTCCCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTTTCTTTCTTT".to_string(),
            "TCTTCCTTTTCCTTCTTTCCTTTTCCTTTTCCTTCCTTCCTTCCTCCTTCCTTCCTTCCTTCCTCCCTCCCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCCCTCCCTCCCTCCCTCTCCCTCCCTTCTCCCTCTCCCTTCTTCCTTCCTTTTCTTCCTTTTTCTTCCTTCTTTCCTTCTTCCTTTCTTCTTTCTTTCCTTTCCTTTCTTTCTTTCTTTCTTCTTTTTCTTCTTTCTTTCTTTTTTCTTTCTTTCTTCCTTTTTTCTTTCTTTTTCTTTCCTTTTTCTTCTTTTTCTTTCTTTCTTTCTTCTTTTCTTTCTTTCTTTCTTTCTTTCCTTTTTCTTCCTTTCTTTCTTTCCTTTTTCTTTCTTTCTTCCTTCTTTCTTTCTTTCTTTCTTTTTCTTTCCTTCCTTTTCTTTCTTTCTTTCTTTCTTTCTTTCCTTTTTCTTCTTTCCTTCTCTCTTTTCTTCCTTTTTCCTTTCTTTCCTTCTTTTTCTTTCCTTTCTTTTTCTTCCTTTCTCTCTTTTTCTTTCTTTCCTTTTCTTTCCTTTCTCTCTTTCTTCCTTTTTCTTCCTTTTCTTTCTTCTTCTTTCTTTCCTTTTCTTTCCTTTCTTTCCTTTTTCTTCCTTTTCTTTCTTTCTTTCTTTCTTCCTTCTTTCTTTCCTTTCTTTCTTTCTTCTTTCTTTCCTTTCTTTCTTTCCTTTTTCTTCTTTCCTTCTTCTTTCCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTTTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCCCTCTCCCTCTCCCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTTTCTTCTTTCTTTCTTTCCTG".to_string(),
            "TCTTTCTTTCTTTCTTTGCTTTCCTTTCTTTCCTTTCCTTTCCTTTCCTTCCTTCCTTCTTCCTTCCTTCCCTTCCTCCCTCCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCCCTCTCCCTCTCCCTCTCCCTCCCTCTCCCTCTCCCTCTCCCTCTCTCTCCCTCTCTCTGCCTCTCCCTCTCCCTCTCCCTCTCCTCTCCCTCTCCCTCCCTCCCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCTCTCCCTCCCTCCCTCTCTCTCCTCTCCCTCACCCTCTCCCTCTCCCTCTCCCTCTCCTCTCCCTCTCCCTCTCCTCTCCCTCCCTCTCCCCTCCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCTCTCCCTCTCCCTCTCCCTCTCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCTCTCCCTCTCCCTCTCCCCTCCTCCTCCCTCTCCTCTCCCTCTCCCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCTCTCCCTCTCCCTCTCCCTCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCCTCCCTCTCCCTCTCCCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTTTCTTTCTTT".to_string(),
            "TCTTTCTTTCTTTCTTTCCTTTCCTTTCCTTTCCTTTCCTTTCCTTCCTTTCCTTCCTTCCTTCCTTCCTTCCTTCCTCCCTCCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCCCCTCTCCCTCTCCTCCTCCTCCTCTCCTCTCCTCTCCCTCTCCTCTCCTCTCCCTCTCTCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCCTCTCCCTCTCCTCTCCCTCTCCTCTCCTCTCCCTCTCCTCCTCTCCCTCTCCTCTCCCTCTCCTCTCCCCTCTCCTCTCCCTCTCCCTCTCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCTCTCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCTCTCCCTCTCCCCTCTCCCTCTCCCTCTCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCTCTCCTCTCCTCTCCTCTCCCTCTCCTCTCCCTCTCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCCCTCTCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTTTCTTTCTTT".to_string(),
            "TCTTTCTTTTCTTTCTTTCCTTTCCTTTCCTTTCTTTCCTTTCCTTCCTTTCCTTCCTTCCTTCCTTCCTTCCTTCCTCCCTCCCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCCCTCTCCCTCTCCCTCCCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCTCCCTCTCCCTCTCTCCCTCTCCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCTCCCTCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCTCTCCCTCTCCCTCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCTCCCTCTCCTCTCTCCCTCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCTCCCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCTCTCTCTCTCCCTCTCCCTCTCCCTCTCCCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTTTCTTTTTCTTT".to_string(),
            "TCTTTCTTTCTTTCTGCTTTCCTTTCCTTTCCTTTCCTTTCCTTTCCTTCCTTTCCTTCCTTCCTTCCTTCCTTCCTTCCTCCCTCCTCTCTCTCTCTCTCTCTCTCTCTCTTTCCTCCTCCCTCCCTCCCTCCCTCTCCCTCCCTCTCCCTCCTCCCTCTCCCTCTCCCTCCTCTCCCTCCCTCCCTCTCCCTCCCTCTCCCTCTCCCTCTCTCCCTCTCCTCTCCTCTCCCTCTCCCTCTCCTCTCCCTCCTCCCTCTCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCTCTCCCTCTCTCCCACCTCTCCCTCTCCCTCTCCCTCCCTCCCTCTCCTCTCCCTCTCCCTCCCTCCTCCCTCTCCCTCTCCCTCTCCCTCTCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCTCTCCTCTCCCCCTCTCCCTCTCCCTCTCCCTCCTCCCTCTCCCCTCTCCCCCACCCCTCTCCCCTCTCCCTCCCTCTCCCTCTCCCCTCTCCCTCTCCCTCTCCCTACTCCCTCCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCTCCCTCTCCCTCTCCCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTTTCTTTCTTT".to_string(),
            "TCTTTCTTTCTTTCTTTCCTTCCTTTCCTTTTCCTTTCCTTTCCTTCCTTTCCTTCCTTCCTTCCTTCCTTCCTTCCTCCCTCCCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCCCTCTCCCTCCCTCTCTCCCTCCCTCTCCCTCTCTCCCTCCCTCTCCCTCTCCCTCTCCCTCTCTCTCTCCCTCCCTCTCCCTCTCCCTCTCTCTCCCTCCCTCTCCCTCCCTCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCTCCCTCCCTCTCCCTCTCCCTCTCTCCCTCTCCCTCTCCCTCTCCCTCTCTCCCTCTCCCTCCCTCTCCCTCTCCCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCTCCCTCTCCCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCCCTCTCCCTCTCTCTCTCTCTCTCCCTCTCCCTCTCTCCCTCCCTCCCTCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCCTCTCCCTCTCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTTTCTTTCTTT".to_string(),
            "TCTTTCTTTCTTTCTTTCCTTTCCTTTCCTTTCCTTTCCTTTCCTTCCTTTCCTTCCTTCCTTCCTTCCTTCCTCCCTCCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCCCTCTCCCTCTCCCTCTCCCTCCCTCTCCCTCTCCCTCCTCTCCCTCTCCCTCTCCCTCTCCCTCCTCTCCTCTCCTCTCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCTTCTCCTCTCCTCTCCCTCTCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCCCCTCTCCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCTCTCCCTCTCCCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCTCCCTCTCCCTCCTCTCCCTCTCCCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTTTCTTTCTTT".to_string(),
            "CTTTCTTTCTTTCTTTCTTTCCTTTCCTTTCCTTTCCTTTCCTTCCTTTCCTTCCTTCCTTCCTTCCTTCCTTCCTCCCTCCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCCCTCTCCCTCTCCCTCTCCCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCCCTCCTCTCCCTCCTCCTCTCCCTCTCCCTCTCCCTCTCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCTCTCCCTCTCCCTCTCCCTCCTCCCTCCCTCCCTCTCCCTCTCCCTCCTCCCTCTCCTCTCCTCTCCCTCTCCCTCTTTCCCTCTCCTCTCCCTCTCCTCTCCCTCTCCCCTCTCCCTCTCCTCTCCTCTCCCTCTCCTCTCCTCTCCCTCTCCTCTCCCTCTCCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCTCCCTCCCTCTCCTCTCCCTCTCCCTCTCCTCTCCCTCTCCTCTCCCTCTCCCTCTCCCCTCTCCCTCTCCCCTCTCCCTCTCCTCTCCTCTCCCTCTCCCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTCTTTCTTTCTTTTCTTTC".to_string(),        
                ];
        let mut seqs_bytes = vec![];
        for seq in seqs.iter() {
            seqs_bytes.push(seq.to_string().bytes().collect::<Vec<u8>>());
        }

        // I empirically determined the following parameters to be suitable,
        // but further testing on other repeats would be good
        // mainly have to make sure the consensus does not get longer than the individual insertions
        let scoring = Scoring::new(-12, -6, |a: u8, b: u8| if a == b { 3 } else { -4 });
        let mut aligner = Aligner::new(scoring, &seqs_bytes[0]);
        for seq in seqs_bytes.iter().skip(1) {
            aligner.global(seq).add_to_graph();
        }

        let consensus = aligner.consensus();
        let score = aligner.global(&consensus).alignment().score;


        println!("Consensus: {}", std::str::from_utf8(&consensus).unwrap());
        println!("Consensus score: {}", score);
    }

    #[test]
    fn test_consensus_4() {
        let seqs = vec![
            "TTTCTTTCTTTCTTTCTTTCTT".to_string(),
            "TTTCTTTCTTTCTTTCTTTCTTTCTTTTTTTT".to_string(),
            "TTTCTTTCTTTCTTTCTTTCTTTCTTTTT".to_string(),
            "TTTCTTTCTTTCTTTCTTTCTT".to_string(),
            "TTTCTTTCTTTCTTTCTTTCTTTCTTT".to_string(),
            "ACTTCTTTCTTTCTTTCTTTCTTTCTTTT".to_string(),
            "TTTCTTTCTTTTCTTTCTTTCTTTCTT".to_string(),
            "TTTTCTTTCTTTCTTTCTTTCTTTCTTTT".to_string(),
            "TTTCTTTTCTTTCTTTCTTTCTTTCTTTTT".to_string(),
            "TTTCTTTCTTTTCTTTCTTTCTTTCTTT".to_string(),
            "TTTCTTTCTTTCTTTCTTTCTTTCT".to_string(),
            "TTTCTTTCTTTCTTTCTTTCTTTCTTTT".to_string(),
            "CTCTCTTTCTTTTCTTTCTTTCTTTTTCTTT".to_string(),
            "TTTCTTTCTTTCTTTCTTTCTT".to_string(),
            "TTTCTTTCTTTCTTTCTTTTCTTTCTTTT".to_string(),
            "TCGTTTCTTTCTTTCTTTCTTTCTTTCTTT".to_string(),
            "TTCTTTCTTTCTTTCTTTTTTTTTC".to_string(),
            "TTTCTTTCTTTCTTTCTTTCTTTCTT".to_string(),
            "TTTCTTTCTTTTTTTTCTTTCTTTCTTTCTTTT".to_string(),
            "TTTCTTTCTTTCTTTCTTTCTTTCTTTTT".to_string()];
        let mut seqs_bytes = vec![];
        for seq in seqs.iter() {
            seqs_bytes.push(seq.to_string().bytes().collect::<Vec<u8>>());
        }

        // I empirically determined the following parameters to be suitable,
        // but further testing on other repeats would be good
        // mainly have to make sure the consensus does not get longer than the individual insertions
        let scoring = Scoring::new(-12, -6, |a: u8, b: u8| if a == b { 3 } else { -4 });
        let mut aligner = Aligner::new(scoring, &seqs_bytes[0]);
        for seq in seqs_bytes.iter().skip(1) {
            aligner.global(seq).add_to_graph();
        }

        let consensus = aligner.consensus();
        let score = aligner.global(&consensus).alignment().score;
        
        println!("Consensus: {}", std::str::from_utf8(&consensus).unwrap());
        println!("Consensus score: {}", score);
    }


    #[test]
    fn test_consensus_5(){
        let seqs = vec!["TATATATATATAAACATATATTATATATATAAAATATAACATATATAAACATATATATTATATATATA".to_string(),
            "TATATATATATAAACATATATTATATATGTAATATAAACATATATAAACATATATTATATATA".to_string(),
            "TATATATATATAAACATATATTATATATAATATAAACATATATAAACATATATTATATATATA".to_string(),
            "TATATATATATAAACATATATTATATATGTAATATAAACATATATAAACATATATTATATATATA".to_string(),
            "ATATATATAAACATATATTATATATGTAATATAAATATATATAAACATATATTTATATATATA".to_string(),
            "TATATATATATAAACATATATTATATATGTAATATAAACATATATGTATACATATATATACA".to_string(),
            "TATATATATATAAACATATATTATATATGTAATATAAATATATATAAACATATATTATATATATA".to_string(),
            "TATATATATATAAACATATATTATATATGTAATATAAACATATATAAACATATATTATATATATA".to_string(),
            "TATATATTTATAAACATATATTATGTATGTAATATAAACATATATAAACATATATTATATATA".to_string(),
            "TATATATATATAAACATATATTATATATATATAAACATATATAAACATATATTATATATATA".to_string(),
            "TATATATATATAAACATATATTCTATATATGTAATATAAACATATATAAACATATATTATCTATATA".to_string(),
            "TATATATATATAAACATATATTATATATAATATAAACATATAAACATATATTATATATATA".to_string(),
            "TATATATATATAAACATATATTATATATGTAATATAAACATATATAAACATATATTATATATATA".to_string(),
            "TATATATATATAAACATATATTATATATGTAATATGTTTTCTATATGTTGCTATATTATACAACATA".to_string(),
            "ATATATATATATAAACATATATTATATATGTAATATAAACATATATAAACATATATTATATATATATA".to_string(),
            "TATATATATATAAACATATATTATATATGTAATATAACATATATAAACATATATTATATATATA".to_string(),
            ];
        let mut seqs_bytes = vec![];
        for seq in seqs.iter() {
            seqs_bytes.push(seq.to_string().bytes().collect::<Vec<u8>>());
        }

        // I empirically determined the following parameters to be suitable,
        // but further testing on other repeats would be good
        // mainly have to make sure the consensus does not get longer than the individual insertions
        let scoring = Scoring::new(-12, -6, |a: u8, b: u8| if a == b { 3 } else { -4 });
        let mut aligner = Aligner::new(scoring, &seqs_bytes[0]);
        for seq in seqs_bytes.iter().skip(1) {
            aligner.global(seq).add_to_graph();
        }

        let consensus = aligner.consensus();
        let score = aligner.global(&consensus).alignment().score;
        
        println!("Consensus: {}", std::str::from_utf8(&consensus).unwrap());
        println!("Consensus score: {}", score);
}

}
